<!doctype html>
<html>
  <head>
    <title>Auto Collections</title>
    <style>      
    .title-match-container {
        margin-bottom: 10px;
        display: flex;
        flex-direction: column;
        padding: 15px;
        background-color: rgba(0,0,0,0.05);
        border-radius: 4px;
      }
      .collection-header {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
      }
      .collection-name-input {
        flex: 1;
        margin-right: 10px;
      }
      .logical-operator-container {
        margin-right: 10px;
        display: flex;
        align-items: center;
      }
      .operator-label {
        white-space: nowrap;
        margin-right: 5px;
      }
      .filter-condition {
        display: flex;
        align-items: center;
        margin-bottom: 8px;
        flex-wrap: wrap;
        padding: 8px;
        background-color: rgba(0,0,0,0.03);
        border-radius: 4px;
      }
      .match-type-container {
        width: 100px;
        margin-right: 10px;
        flex: 0 0 100px;
      }
      .match-type-select {
        width: 100%;
      }
      .title-match-input {
        flex: 1;
        margin-right: 10px;
      }
      .case-sensitive-check {
        margin-right: 10px;
        display: flex;
        align-items: center;
      }
      .case-label {
        white-space: nowrap;
        margin-right: 5px;
      }
      .add-title-match-button {
        margin-bottom: 15px;
      }
      .add-condition-button {
        margin-top: 5px;
        margin-bottom: 10px;
        align-self: flex-start;
      }
      .add-group-button {
        margin-top: 5px;
        margin-bottom: 10px;
        margin-right: 10px;
        align-self: flex-start;
      }
      .remove-button {
        margin-left: 10px;
        min-width: 40px;
      }
      #title-match-pairs {
        margin-bottom: 20px;
      }
      .filter-conditions {
        width: 100%;
      }
      .filter-group {
        margin-bottom: 8px;
        padding: 10px;
        background-color: rgba(0,0,0,0.02);
        border-radius: 4px;
        border: 1px dashed rgba(0,0,0,0.1);
      }
      .filter-group-header {
        display: flex;
        align-items: center;
        margin-bottom: 10px;
      }
      .filter-group-items {
        padding-left: 20px;
      }
      .help-text {
        font-size: 0.9em;
        color: #888;
        margin-top: 5px;
        margin-bottom: 15px;
      }
    </style>
  </head>

  <body>
    <div
      data-role="page"
      class="page type-interior pluginConfigurationPage tbsConfigurationPage"
      data-require="emby-input,emby-button,emby-select,emby-checkbox"
    >
      <div data-role="content">
        <div class="content-primary">
          <form class="tbsConfigurationPage">
            <div class="sectionTitleContainer flex align-items-center">
              <h2 class="sectionTitle">Auto Collections</h2>
              <a
                is="emby-linkbutton"
                class="raised button-alt headerHelpButton emby-button"
                target="_blank"
                href="https://github.com/johnpc/jellyfin-plugin-Auto-collections"
              >Help</a>
            </div>
            <div class="verticalSection">
              <div class="inputContainer">                <label class="inputLabel inputLabelUnfocused" for="title-match-pairs">Auto Collections:</label>
                <div class="help-text">Create collections based on multiple filter conditions. You can combine filters using either "AND" (all conditions must match) or "OR" (any condition can match). Group conditions using parentheses for complex filtering logic. Select the type (Title, Studio, Genre, Actor, or Director), enter the string to match, and provide a collection name.</div>
                <div id="title-match-pairs"></div>
              </div>
              
              <button
                id="add-title-match-button"
                is="emby-button"
                type="button"
                class="raised add-title-match-button"
              >
                <span>Add Auto Collection</span>
              </button>
              
              <br />
              <button
                id="saveConfiguration"
                is="emby-button"
                class="raised button-submit block"
              >
                <span>Save</span>
              </button>
            </div>
            <br />
            <button
              is="emby-button"
              type="button"
              class="raised block"
              id="sync-Auto-collections"
              onclick="execute()"
            >
              <span>Sync Auto Collections</span>
            </button>
          </form>
        </div>
      </div>      <script type="text/javascript" defer>
        // Function to create a single filter condition element
        function createFilterConditionElement(matchValue = '', caseSensitive = false, matchType = 0) {
          const conditionContainer = document.createElement('div');
          conditionContainer.className = 'filter-condition';
          
          // Create match type dropdown
          const matchTypeContainer = document.createElement('div');
          matchTypeContainer.className = 'match-type-container';
          
          const matchTypeSelect = document.createElement('select');
          matchTypeSelect.is = 'emby-select';
          matchTypeSelect.className = 'match-type-select';
            
          // Add match type options
          const options = [
            { value: '0', text: 'Title' },
            { value: '1', text: 'Genre' },
            { value: '2', text: 'Studio' },
            { value: '3', text: 'Actor' },
            { value: '4', text: 'Director' }
          ];
          
          options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt.value;
            option.text = opt.text;
            matchTypeSelect.appendChild(option);
          });
            
          // Set the selected option based on matchType parameter
          if (matchType !== undefined) {
            matchTypeSelect.value = matchType.toString();
          }
          
          matchTypeContainer.appendChild(matchTypeSelect);
          
          // Create a dynamic update for the placeholder text based on the selected match type
          const updatePlaceholder = (select) => {
            const matchType = parseInt(select.value, 10);
            const input = conditionContainer.querySelector('.title-match-input');
            if (input) {
              switch(matchType) {
                case 1: // Genre
                  input.placeholder = 'Genre to match (e.g. Action, Comedy)';
                  break;
                case 2: // Studio
                  input.placeholder = 'Studio to match (e.g. Marvel, Paramount)';
                  break;
                case 3: // Actor
                  input.placeholder = 'Actor name to match (e.g. Tom Hanks, Scarlett)';
                  break;
                case 4: // Director
                  input.placeholder = 'Director name to match (e.g. Spielberg, Nolan)';
                  break;
                default: // Title
                  input.placeholder = 'Text in title to match';
              }
            }
          };
          
          // Add change event to update placeholder when match type changes
          matchTypeSelect.addEventListener('change', () => {
            updatePlaceholder(matchTypeSelect);
          });
            
          // Create match value input
          const titleMatchContainer = document.createElement('div');
          titleMatchContainer.style.flex = '1 1 200px';
          titleMatchContainer.style.marginRight = '10px';
          
          const titleMatchInput = document.createElement('input');
          titleMatchInput.is = 'emby-input';
          titleMatchInput.type = 'text';
          titleMatchInput.className = 'title-match-input';
          titleMatchInput.style.width = '100%';
          titleMatchInput.placeholder = 'Match String';
          titleMatchInput.value = matchValue;
          
          titleMatchContainer.appendChild(titleMatchInput);
          
          // Set initial placeholder based on match type
          setTimeout(() => updatePlaceholder(matchTypeSelect), 0);
            
          // Create case-sensitive checkbox
          const caseCheckContainer = document.createElement('div');
          caseCheckContainer.className = 'case-sensitive-check';
          caseCheckContainer.style.flex = '0 0 auto';
          caseCheckContainer.style.display = 'flex';
          caseCheckContainer.style.alignItems = 'center';
          
          const caseCheckboxWrapper = document.createElement('div');
          caseCheckboxWrapper.style.marginRight = '5px';
          
          const caseCheckbox = document.createElement('input');
          caseCheckbox.is = 'emby-checkbox';
          caseCheckbox.type = 'checkbox';
          caseCheckbox.className = 'case-sensitive-checkbox';
          caseCheckbox.checked = caseSensitive;
          
          const caseLabel = document.createElement('label');
          caseLabel.className = 'case-label';
          caseLabel.textContent = 'Case Sensitive';
          caseLabel.style.fontSize = '14px';
          
          caseCheckboxWrapper.appendChild(caseCheckbox);
          caseCheckContainer.appendChild(caseCheckboxWrapper);
          caseCheckContainer.appendChild(caseLabel);
          
          // Create remove button for this condition
          const removeButton = document.createElement('button');
          removeButton.is = 'emby-button';
          removeButton.type = 'button';
          removeButton.className = 'remove-button';
          removeButton.innerHTML = '<span>✕</span>';
          removeButton.style.flex = '0 0 auto';
          removeButton.style.minWidth = '32px';
          removeButton.style.height = '32px';
          removeButton.style.padding = '0';
          removeButton.style.borderRadius = '50%';
          
          // Initialize the Emby components
          setTimeout(() => {
            if (matchTypeSelect.embyInit) {
              matchTypeSelect.embyInit();
            } else if (window.EmbyWebComponents && window.EmbyWebComponents.autoFocus) {
              window.EmbyWebComponents.autoFocus(matchTypeSelect.parentNode);
            }
          }, 0);
          
          // Add all components to condition container
          conditionContainer.appendChild(matchTypeContainer);
          conditionContainer.appendChild(titleMatchContainer);
          conditionContainer.appendChild(caseCheckContainer);
          conditionContainer.appendChild(removeButton);
          
          // Add click handler for remove button
          removeButton.onclick = function() {
            // Don't allow removing the last item in a group
            const parent = conditionContainer.parentElement;
            if (parent && parent.querySelectorAll(':scope > .filter-condition, :scope > .filter-group').length > 1) {
              conditionContainer.remove();
            } else {
              alert("Cannot remove the last item in a group. Every group needs at least one condition or subgroup.");
            }
          };
          
          return conditionContainer;
        }
        
        // Function to create a filter group element (group of conditions or other groups)
        function createFilterGroupElement(logicalOperator = 0, items = []) {
          const groupContainer = document.createElement('div');
          groupContainer.className = 'filter-group';
          
          // Create group header with operator selector
          const groupHeader = document.createElement('div');
          groupHeader.className = 'filter-group-header';
          
          const operatorLabel = document.createElement('label');
          operatorLabel.className = 'operator-label';
          operatorLabel.textContent = 'Combine with:';
          
          const operatorSelect = document.createElement('select');
          operatorSelect.is = 'emby-select';
          operatorSelect.className = 'logical-operator-select';
          operatorSelect.style.marginLeft = '5px';
          operatorSelect.style.marginRight = '10px';
          
          const orOption = document.createElement('option');
          orOption.value = '0';
          orOption.text = 'OR';
          operatorSelect.appendChild(orOption);
          
          const andOption = document.createElement('option');
          andOption.value = '1';
          andOption.text = 'AND';
          operatorSelect.appendChild(andOption);
          
          // Set the selected option based on provided logical operator
          operatorSelect.value = logicalOperator.toString();
          
          // Create remove button for this group
          const removeButton = document.createElement('button');
          removeButton.is = 'emby-button';
          removeButton.type = 'button';
          removeButton.className = 'remove-button';
          removeButton.innerHTML = '<span>✕</span>';
          removeButton.style.flex = '0 0 auto';
          removeButton.style.minWidth = '32px';
          removeButton.style.height = '32px';
          removeButton.style.padding = '0';
          removeButton.style.borderRadius = '50%';
          
          // Add click handler for remove button
          removeButton.onclick = function() {
            // Don't allow removing the root group
            const parent = groupContainer.parentElement;
            if (!parent.classList.contains('filter-expression-root')) {
              // Make sure it's not the last item in its parent group
              if (parent && parent.querySelectorAll(':scope > .filter-condition, :scope > .filter-group').length > 1) {
                groupContainer.remove();
              } else {
                alert("Cannot remove the last item in a group. Every group needs at least one condition or subgroup.");
              }
            } else {
              alert("Cannot remove the root group.");
            }
          };
          
          groupHeader.appendChild(operatorLabel);
          groupHeader.appendChild(operatorSelect);
          groupHeader.appendChild(removeButton);
          
          // Container for group items (conditions or nested groups)
          const groupItems = document.createElement('div');
          groupItems.className = 'filter-group-items';
          
          // If no items provided, add a default condition
          if (!items || items.length === 0) {
            groupItems.appendChild(createFilterConditionElement());
          } else {
            // Add each provided item
            items.forEach(item => {
              if (typeof item === 'function') {
                groupItems.appendChild(item());
              } else {
                groupItems.appendChild(item);
              }
            });
          }
          
          // Add buttons for adding conditions or nested groups
          const buttonsContainer = document.createElement('div');
          buttonsContainer.className = 'group-buttons';
          buttonsContainer.style.display = 'flex';
          buttonsContainer.style.marginTop = '10px';
          
          const addConditionButton = document.createElement('button');
          addConditionButton.is = 'emby-button';
          addConditionButton.type = 'button';
          addConditionButton.className = 'raised add-condition-button';
          addConditionButton.innerHTML = '<span>Add Condition</span>';
          addConditionButton.onclick = function() {
            groupItems.appendChild(createFilterConditionElement());
          };
          
          const addGroupButton = document.createElement('button');
          addGroupButton.is = 'emby-button';
          addGroupButton.type = 'button';
          addGroupButton.className = 'raised add-group-button';
          addGroupButton.innerHTML = '<span>Add Group (Parentheses)</span>';
          addGroupButton.onclick = function() {
            groupItems.appendChild(createFilterGroupElement());
          };
          
          buttonsContainer.appendChild(addConditionButton);
          buttonsContainer.appendChild(addGroupButton);
          
          // Add all components to the group container
          groupContainer.appendChild(groupHeader);
          groupContainer.appendChild(groupItems);
          groupContainer.appendChild(buttonsContainer);
          
          // Initialize the Emby components
          setTimeout(() => {
            if (operatorSelect.embyInit) {
              operatorSelect.embyInit();
            } else if (window.EmbyWebComponents && window.EmbyWebComponents.autoFocus) {
              window.EmbyWebComponents.autoFocus(operatorSelect.parentNode);
            }
          }, 0);
          
          return groupContainer;
        }
        
        // Function to create a title match pair element (collection with filter expression)
        function createTitleMatchPairElement(collectionName = '', rootGroup = null) {
          const container = document.createElement('div');
          container.className = 'title-match-container';
          
          // Create the collection header (name)
          const collectionHeader = document.createElement('div');
          collectionHeader.className = 'collection-header';
          
          // Collection name input
          const collectionNameContainer = document.createElement('div');
          collectionNameContainer.style.flex = '1';
          
          const collectionNameInput = document.createElement('input');
          collectionNameInput.is = 'emby-input';
          collectionNameInput.type = 'text';
          collectionNameInput.className = 'collection-name-input';
          collectionNameInput.style.width = '100%';
          collectionNameInput.placeholder = 'Collection Name';
          collectionNameInput.value = collectionName;
          
          collectionNameContainer.appendChild(collectionNameInput);
          
          // Remove collection button
          const removeButton = document.createElement('button');
          removeButton.is = 'emby-button';
          removeButton.type = 'button';
          removeButton.className = 'remove-button';
          removeButton.innerHTML = '<span>✕</span>';
          removeButton.style.minWidth = '32px';
          removeButton.style.height = '32px';
          removeButton.style.padding = '0';
          removeButton.style.borderRadius = '50%';
          removeButton.onclick = function() {
            container.remove();
          };
          
          collectionHeader.appendChild(collectionNameContainer);
          collectionHeader.appendChild(removeButton);
          
          // Container for filter expression
          const filterExpressionRoot = document.createElement('div');
          filterExpressionRoot.className = 'filter-expression-root';
          
          // Create the root filter group if not provided
          if (!rootGroup) {
            filterExpressionRoot.appendChild(createFilterGroupElement());
          } else {
            filterExpressionRoot.appendChild(rootGroup);
          }
          
          // Add all components to the main container
          container.appendChild(collectionHeader);
          container.appendChild(filterExpressionRoot);
          
          return container;
        }
        
        // Helper function to collect the data from the filter expression UI
        function buildFilterExpressionFromUI(groupElement) {
          // Get the logical operator for this group
          const operatorSelect = groupElement.querySelector(':scope > .filter-group-header > .logical-operator-select');
          const logicalOperator = parseInt(operatorSelect.value, 10);
          
          // Create the filter group object
          const group = {
            type: 1, // Group type
            operator: logicalOperator,
            items: []
          };
          
          // Process each item in the group (conditions and nested groups)
          const itemsContainer = groupElement.querySelector(':scope > .filter-group-items');
          const itemElements = itemsContainer.querySelectorAll(':scope > .filter-condition, :scope > .filter-group');
          
          itemElements.forEach(itemElement => {
            if (itemElement.classList.contains('filter-condition')) {
              // Process filter condition
              const matchValueInput = itemElement.querySelector('.title-match-input');
              const caseSensitiveCheckbox = itemElement.querySelector('.case-sensitive-checkbox');
              const matchTypeSelect = itemElement.querySelector('.match-type-select');
              
              if (matchValueInput && matchValueInput.value.trim()) {
                const matchValue = matchValueInput.value.trim();
                const caseSensitive = caseSensitiveCheckbox ? caseSensitiveCheckbox.checked : false;
                const matchTypeValue = parseInt(matchTypeSelect ? matchTypeSelect.value : '0', 10);
                
                // Convert numeric value to enum string representation
                let matchTypeString;
                switch (matchTypeValue) {
                  case 0: matchTypeString = "Title"; break;
                  case 1: matchTypeString = "Genre"; break;
                  case 2: matchTypeString = "Studio"; break;
                  case 3: matchTypeString = "Actor"; break;
                  case 4: matchTypeString = "Director"; break;
                  default: matchTypeString = "Title";
                }
                
                // Add the condition to the group
                group.items.push({
                  type: 0, // Condition type
                  condition: {
                    MatchValue: matchValue,
                    CaseSensitive: caseSensitive,
                    MatchType: matchTypeString
                  }
                });
              }
            } 
            else if (itemElement.classList.contains('filter-group')) {
              // Process nested filter group recursively
              const nestedGroup = buildFilterExpressionFromUI(itemElement);
              if (nestedGroup && nestedGroup.items && nestedGroup.items.length > 0) {
                group.items.push(nestedGroup);
              }
            }
          });
          
          return group;
        }
        
        // Function to convert legacy format to basic filter expression
        function convertLegacyFormatToExpression(pair) {
          if (!pair) return null;
          
          // Create a root group
          const rootGroup = {
            type: 1, // Group type
            operator: pair.LogicalOperator || 0, // Default to OR
            items: []
          };
          
          // If we have filter conditions, add them to the root group
          if (pair.FilterConditions && pair.FilterConditions.length > 0) {
            pair.FilterConditions.forEach(filter => {
              if (filter.MatchValue) {
                rootGroup.items.push({
                  type: 0, // Condition type
                  condition: {
                    MatchValue: filter.MatchValue,
                    CaseSensitive: !!filter.CaseSensitive,
                    MatchType: filter.MatchType
                  }
                });
              }
            });
          }
          // Otherwise, create a single condition from the legacy fields
          else if (pair.TitleMatch) {
            rootGroup.items.push({
              type: 0, // Condition type
              condition: {
                MatchValue: pair.TitleMatch,
                CaseSensitive: !!pair.CaseSensitive,
                MatchType: pair.MatchType
              }
            });
          }
          
          return rootGroup;
        }
        
        // Function to build UI elements from a filter expression object
        function createFilterGroupElementFromExpression(group) {
          if (!group || !group.items) return createFilterGroupElement();
          
          // Create items for the group
          const items = [];
          
          group.items.forEach(item => {
            if (item.type === 0 && item.condition) {
              // Convert match type string to numeric value
              let matchTypeValue = 0;
              if (typeof item.condition.MatchType === 'string') {
                switch (item.condition.MatchType) {
                  case "Title": matchTypeValue = 0; break;
                  case "Genre": matchTypeValue = 1; break;
                  case "Studio": matchTypeValue = 2; break;
                  case "Actor": matchTypeValue = 3; break;
                  case "Director": matchTypeValue = 4; break;
                  default: matchTypeValue = 0;
                }
              } else if (typeof item.condition.MatchType === 'number') {
                matchTypeValue = item.condition.MatchType;
              }
              
              // Create a condition element
              items.push(createFilterConditionElement(
                item.condition.MatchValue, 
                item.condition.CaseSensitive, 
                matchTypeValue
              ));
            }
            else if (item.type === 1) {
              // Create a nested group element recursively
              items.push(createFilterGroupElementFromExpression(item));
            }
          });
          
          // Create and return the group element
          return createFilterGroupElement(group.operator, items);
        }
        
        function loadConfig() {
          window.ApiClient.getPluginConfiguration(
            "06ebf4a9-1326-4327-968d-8da00e1ea2eb"
          ) // Plugin Id
            .then(function (config) {
              const titleMatchPairsContainer = document.querySelector("#title-match-pairs");
              titleMatchPairsContainer.innerHTML = '';
                
              // Check if we have the TitleMatchPairs property
              if (config.TitleMatchPairs && config.TitleMatchPairs.length > 0) {
                config.TitleMatchPairs.forEach(pair => {
                  let rootGroup = null;
                  
                  // Check if we have the new filter expression model
                  if (pair.FilterExpression && pair.FilterExpression.items && pair.FilterExpression.items.length > 0) {
                    rootGroup = createFilterGroupElementFromExpression(pair.FilterExpression);
                  }
                  // Otherwise, convert from the older formats
                  else {
                    const expression = convertLegacyFormatToExpression(pair);
                    rootGroup = createFilterGroupElementFromExpression(expression);
                  }
                  
                  // Create the collection element with its filter expression
                  const element = createTitleMatchPairElement(pair.CollectionName, rootGroup);
                  titleMatchPairsContainer.appendChild(element);
                });
              } 
              else {
                // If no configuration exists yet, add one empty collection
                const element = createTitleMatchPairElement();
                titleMatchPairsContainer.appendChild(element);
              }
            })
            .catch(function (error) {
              console.error(error);
              // Add an empty collection if there's an error
              const element = createTitleMatchPairElement();
              document.querySelector("#title-match-pairs").appendChild(element);
            });
        }
          
        function saveConfig() {
          const titleMatchContainers = document.querySelectorAll('.title-match-container');
          const titleMatchPairs = [];
            
          titleMatchContainers.forEach(container => {
            // Get collection name
            const collectionNameInput = container.querySelector('.collection-name-input');
            const collectionName = collectionNameInput.value.trim();
            
            // Get the root filter group
            const rootGroupElement = container.querySelector('.filter-expression-root > .filter-group');
            
            if (rootGroupElement && collectionName) {
              // Build the filter expression from the UI
              const filterExpression = buildFilterExpressionFromUI(rootGroupElement);
              
              // Only add if we have valid conditions
              if (filterExpression.items.length > 0) {
                // For backward compatibility, also set the TitleMatch and MatchType fields
                // using the first condition if available
                let firstCondition = null;
                let firstOperator = 0;
                
                // Find the first actual condition in the expression
                const findFirstCondition = (group) => {
                  if (!group || !group.items) return null;
                  
                  for (const item of group.items) {
                    if (item.type === 0 && item.condition) {
                      firstOperator = group.operator;
                      return item.condition;
                    }
                    else if (item.type === 1) {
                      const nestedCondition = findFirstCondition(item);
                      if (nestedCondition) return nestedCondition;
                    }
                  }
                  return null;
                };
                
                firstCondition = findFirstCondition(filterExpression);
                
                // Create filter conditions list for backward compatibility
                const flattenConditions = (group) => {
                  if (!group || !group.items) return [];
                  
                  let conditions = [];
                  
                  for (const item of group.items) {
                    if (item.type === 0 && item.condition) {
                      conditions.push(item.condition);
                    }
                    else if (item.type === 1) {
                      conditions = conditions.concat(flattenConditions(item));
                    }
                  }
                  
                  return conditions;
                };
                
                const filterConditions = flattenConditions(filterExpression);
                
                // Create the full title match pair object
                const titleMatchPair = {
                  TitleMatch: firstCondition ? firstCondition.MatchValue : '',
                  CollectionName: collectionName,
                  CaseSensitive: firstCondition ? firstCondition.CaseSensitive : false,
                  MatchType: firstCondition ? firstCondition.MatchType : "Title",
                  FilterConditions: filterConditions,
                  LogicalOperator: firstOperator,
                  FilterExpression: filterExpression
                };
                
                titleMatchPairs.push(titleMatchPair);
              }
            }
          });
          
          const config = {
            TitleMatchPairs: titleMatchPairs,
            // Keep these empty for backward compatibility
            TagTitlePairs: [],
            Tags: []
          };
          
          window.ApiClient.updatePluginConfiguration(
            "06ebf4a9-1326-4327-968d-8da00e1ea2eb",
            config
          )
            .then(() => alert("Update success"))
            .catch(function (error) {
              console.error(error);
              alert("Error saving configuration");
            });
        }
          function execute() {
          var request = {
            url: ApiClient.getUrl("/AutoCollections/AutoCollections"),
            type: "POST"
          };

          ApiClient.fetch(request)
            .then(function () {
              Dashboard.alert("Executing Auto Collections...");
            })
            .catch(function () {
              Dashboard.alert({
                message: "Unexpected error occurred!"
              });
            });
        }

        // Initialize the page
        loadConfig();
        
        // Add event listeners
        document.querySelector("#saveConfiguration").addEventListener("click", saveConfig);
        document.querySelector("#add-title-match-button").addEventListener("click", function() {
          const element = createTitleMatchPairElement();
          document.querySelector("#title-match-pairs").appendChild(element);
        });
      </script>
    </div>
  </body>
</html>
